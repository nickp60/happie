---
title: "validation"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("GitHub/happie/validation/")
library(tidyverse)
```

## Data

We downloaded the word doc of the supplementary data fro Casjens 2013, and then transformated that into a slightly less terrible excel file.  This was difficult, as between 2003 and now, everything from gene names to taxonomy changed.  The original link to the repository at Venter is broken, and so I had to spend a fair amount of time manually combing the databases for likely strains. 


```{r}


dat <- readxl::read_xlsx("./casjen2003.xlsx", sheet = 2)
dat <- dat %>% fill(host, ftp, assembly) #%>% View()
(dat$start_gene <- gsub("(.*)[…\\.]*(.*)", "\\1", dat$genes))
dat$ftp_gbk <- gsub(".fna.gz", ".gbff.gz", dat$ftp)

```

Then, for testing, I downloaded one:

```{r}
dir.create("genomes")
test_file_path <- "genomes/tmp.gbk"
this_path <- dat[1, "ftp_gbk"]
if (!file.exists(test_file_path)){
  cmd <- paste("curl -L", this_path, "| gunzip  >", test_file_path)
  print(cmd)
  system(cmd)
}
```
Now, for this genome, we need to see if a locus tag given ("AgrC0835"") actually match whats in the file.  They dont in this case (old locus tag is "Agr_C_835"). The fun continues; these must be added manually.

So, I downloaded them all:
```{r exec=F}
for (i in 1:nrow(dat)){
  test_file_path <- file.path("genomes", paste0(gsub(" ", "_", dat$host[i]), ".gbk"))
  this_path <- dat[i, "ftp_gbk"]
  if (!file.exists(test_file_path)){
    cmd <- paste("curl -L", this_path, "| gunzip  >", test_file_path)
    print(cmd)
    system(cmd)
  }
}
```
We need a new copy of the table to annotate:

```{r}
file.copy(from = "./casjen2003.xlsx", to="./casjen2003_newloci.xlsx", overwrite = F)
#write.table(dat, file="annotated.csv", sep=",", row.names = F)
```

Next I had the enviable jot of going entry by entry, and trying to find the annotated phage region's coords now that the locus tags are different.  In practice, this meant finding the first and last listed locus tags (or the next one, if the first could not be found), and entering in the start or end coord, respectively.

Occasionally (such as for E. coli EDL933) I would have to get the RefSeq (GCA) version of the Genbank (GCF) version had the wrong locus tags.

Escherichia coli O157:H7 EDL933 appeared to be using locus tag nomencalture from another organisms, so I had to skip that one.  Genes that were from the same operon had locus tags scattered in distant parts of this genome.

I was unable to match annotations for the following organisms:
- Escherichia coli O157:H7 EDL933
- Mesorhizobium loti     MAFF303099

I found that the dash in Shewanella MR–1 needs to be changed to a real dash, to avoid errors with prokka.

In instances of just single genes annotated, I just took the first one's start and end coords; we will ignore these

In the meantime, I ran happie on all thos genomes, and prettied up the results, combining them into a single results file:
```{sh}
counter=0; 
for i in ./genomes/*.gbk; do echo $counter $i; name=$(basename ${i%.*}); happie --contigs $i -o ${name}_casjens ; counter=$((counter+1)); done
cat ./*/mobile_genome_coords >> combined_happie_coords
```


## evaluating success
I had to do a bit of munging file names to make sure all the names line up.
```{r}
happie_names = c("path", "program", "type", "sequence", "start", "stop")
happie_dat_raw <- read.csv("combined_happie_coords", sep="\t", header = F, col.names = happie_names, stringsAsFactors = F)

### get those that had empty results files to make dummy entries
#
# for i in ./*/; do if [ ! -s "${i}mobile_genome_coords" ]; then echo $i; fi done
#
missing <- c(
  "Buchnera_aphidicola_Ap_casjens/",
  "Buchnera_aphidicola_Bp_casjens/",
  "Buchnera_aphidicola_Sg_casjens/",
  "Chlamydia_pneumoniae__J139_casjens/",
  "Chlamydia_trachomatis__serovar_D_casjens/",
  "Escherichia_coli_O157_VT-2_Sakai_casjens/",
  "Mycoplasma_genitalium_G-37_casjens/",
  "Mycoplasma_pneumoniae_M129_casjens/",
  "Xanthomonas_axonopodis__903_casjens/")
# add missing directory
tmp <-data.frame(
  path=paste0("/home/1/2/3/4/", missing),  
  program=rep(NA, length(missing)),
  type=rep(NA, length(missing)),
  sequence=rep(NA, length(missing)),
  start=rep(NA, length(missing)),
  stop=rep(NA, length(missing))
)
happie_dat <- rbind(happie_dat_raw, tmp)
happie_dat$short_name <- gsub("\\/(.*?)\\/(.*?)\\/(.*?)\\/(.*?)\\/(.*?)\\/(.*?)\\/(.*)", "\\6", happie_dat$path)
happie_dat$short_name <- gsub("_casjens", "", happie_dat$short_name)


new_dat <- readxl::read_xlsx("./casjen2003_newloci.xlsx", sheet = 2)
new_dat <- new_dat %>% fill(host, ftp, assembly, seq) 
new_dat$short_name <- gsub("\\(", "", gsub("\\)", "", gsub(" ", "_", new_dat$host )))
# These is our check
new_dat$short_name[!(new_dat$short_name %in% happie_dat$short_name)]
happie_dat$short_name[!(happie_dat$short_name %in% new_dat$short_name)]

#merged
mdat <- merge(new_dat, happie_dat, by="short_name")
```

Now, we have our data in.  We can assess 4 difference scenarios

1. genomes with no phage, no phage detected
2. genomes with no phage, phage detected
3. genomes with phage, no phage detected
4. genomes with phage, phage detected


I realize I needed to have a column to add whether or not to include a row.  Theres a bunch of messy rows (single genes, or very unclear notes), so I went back and added a column to address this.

the column has the following identifiers

- intact:  metadata says its excisable, inducible, or filimenetous
- intactish: usually described as X-like, meaning its similar to known family of prophage
- partial: a phagey looking operon, but likely missing genes needed for function
- fragments: one or more phage gene
- remnants: degraded, but looks like an old phage
- unknown: no annotation or annotation unclear



```{r}
mdat$to_score


```




This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
